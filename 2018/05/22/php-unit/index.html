<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>编写优秀的单元测试 | 而废不能半途</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="double-c, chao, 后端, 程序员, laravel, php"><meta name="description" content="总不能还没有努力就向生活妥协。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://double-c.github.io/2018/05/22/php-unit/index.html"><link rel="icon" type="image/png" href="/img/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Double-c"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Double-c" alt="Double-c"><img src="/img/chao-logo-white.png" alt="Double-c"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/img/posts/php-unit.png" alt="编写优秀的单元测试"></div><header class="post__info"><h1 class="post__title">编写优秀的单元测试</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://github.com/Double-C">chao</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-05-22</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/php/">Php</a></li></ul></div></div></header><div class="post__content"><h2 id="编写优秀的单元测试"><a href="#编写优秀的单元测试" class="headerlink" title="编写优秀的单元测试"></a>编写优秀的单元测试</h2><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>太久没写单元测试了</p><p>等有时间再补代码用例</p><p>对知识点能有更好的补充说明。 mark</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>单元测试主要是作为一种良好的实践来编写的。</p><p>它能帮助开发人员识别并修复bug、<strong>重构代码</strong>。</p><ul><li>理想的单元测试应当覆盖程序所有可能的路径</li><li>一个单元测试通常覆盖一个函数或方法中的一个特定路径</li><li>测试方法之间经常有隐含的依赖关系暗藏在测试的实现方案中</li></ul><p>单元测试的目标是尽可能地隔离周边环境的情况下测试每个组件。</p><p>只有隔离了周围环境的影响，才能发现被测试的组件与周边组件间的耦合是否真正被解开。</p><p>所以单元测试也可用于检测代码是否过于耦合。</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="#测试进展">测试进展</a></li><li><a href="#常用命令">常用命令</a></li><li><a href="#常见问题">常见问题</a></li><li><a href="#基础知识">基础知识</a></li><li><a href="#测试的依赖关系">测试的依赖关系</a></li><li><a href="#数据供给器">数据供给器</a></li><li><a href="#测试异常">测试异常</a></li><li><a href="#对输出进行测试">对输出进行测试</a></li><li><a href="#基境">基境</a></li><li><a href="#组织测试">组织测试</a></li><li><a href="#数据库测试">数据库测试</a></li><li><a href="#测试替身">测试替身</a></li><li><a href="#测试实践">测试实践</a></li></ul><h4 id="测试进展"><a href="#测试进展" class="headerlink" title="测试进展"></a>测试进展</h4><p>对于每个测试时的运行，PHPUnit 命令行输出一个字符来指示进展</p><table><thead><tr><th>字符</th><th>进展</th></tr></thead><tbody><tr><td>.</td><td>测试成功时输出<code>.</code></td></tr><tr><td>F</td><td>一个断然失败时输出<code>F</code></td></tr><tr><td>E</td><td>产生一个错误时输出<code>E</code></td></tr><tr><td>R</td><td>当测试被标记为有风险时输出<code>R</code></td></tr><tr><td>S</td><td>当测试被跳过时输出<code>S</code></td></tr><tr><td>I</td><td>测试被标记为不完整或未实现时输出<code>I</code></td></tr></tbody></table><blockquote><p>失败是指违背了 <code>PHPUnit</code> 的断言<br>错误是指意料之外的异常或 <code>PHP</code> 错误<br>这种差异在某些时候是非常有用的，因为错误往往比失败更容易修复<br>如果得到一个非常长的问题列表，那么最有先对付错误</p></blockquote><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phpunit ArrayTest</span><br></pre></td></tr></table></figure><blockquote><p><code>PHPUnit</code> 命令行测试执行器在<strong>当前工作目录</strong>中寻找 <code>ArrayTest.php</code> 源文件并加载之<br>如果在此源文件中能找到 <code>ArrayTest</code> 测试用例类，此类中的测试将被执行</p></blockquote><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>Q：当你想把一些东西写到 <code>print</code> 语句或者调试表达式中时</p><blockquote><p>A: 别这么做，将其写成一个测试来代替</p></blockquote><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li>针对类 <code>Class</code> 的测试写在类 <code>ClassTest</code> 中</li><li><code>ClassTest</code> 通常继承自 <code>PHPUnit\Framework\TestCase</code></li><li>测试通常是命名为 <code>test*</code> 的公用( <code>public</code> )方法</li><li>在测试方法内，类似于 <code>assertEquals()</code> 这样的断言方法用来对实际值于预期值做出断言</li></ul><h4 id="测试的依赖关系"><a href="#测试的依赖关系" class="headerlink" title="测试的依赖关系"></a>测试的依赖关系</h4><p><code>PHPUnit</code> 支持对测试方法之间的显式依赖关系进行声明</p><p>这种依赖关系并不是定义在测试方法的执行顺序中</p><p>而是允许生产者返回一个测试基境( <code>fixture</code> ) 的示例</p><p>并将此实例传递给依赖于它的消费者</p><blockquote><p>生产者( producer ) : 是能生成被测单元并将其作为返回值的测试方法</p><p>消费者（consumer） ： 是依赖于一个或多个生产者及其返回值的测试方法</p></blockquote><p><code>@depends</code> 标注来表达依赖情况</p><p>默认情况下，生产者所产生的返回值将“原样”传递给相应的消费者。</p><p>这意味着如果生产者返回的是一个对象，那么传递给消费者的是一个指向此对象的引用</p><p>如果需要传递对象的副本而非引用，则应当用 @depends clone 替代 @depends</p><h4 id="数据供给器"><a href="#数据供给器" class="headerlink" title="数据供给器"></a>数据供给器</h4><p>测试方法可以接受任意参数</p><p>这些参数可以由数据供给器来提供</p><p>用 <code>@dataProvider</code> 标注来指定哪个数据供给器方法</p><p>数据供给器方法必须声明为 <code>public</code></p><p>其返回值可以是一个数组，其每个元素是一个数组的话，可以利用键值对元素进行说明</p><p>或者是一个实现了 <code>lterator</code> 接口的对象。</p><h4 id="测试异常"><a href="#测试异常" class="headerlink" title="测试异常"></a>测试异常</h4><p>方法：</p><ul><li>expectException()</li><li>expectExceptionCode()</li><li>expectExceptionMessage()</li><li>expectExceptionMessageRegExp()</li></ul><p>可以用于为被测代码所抛出的异常建立预期，也可以使用expectedException标注</p><blockquote><p>默认情况下，PHPUnit将测试在执行中触发的PHP错误、警告、通知都转换为异常</p><p>所以对异常进行测试是越明确越好，对于太笼统的类进行测试有可能导致不良副作用</p></blockquote><h4 id="对输出进行测试"><a href="#对输出进行测试" class="headerlink" title="对输出进行测试"></a>对输出进行测试</h4><p>有时候想要断言某方法的运行过程是否中生成了预期的输出</p><p>断言输出的方法：<code>expectOutputString()</code></p><p>获取程序输出的方法：<code>getActualOutput()</code></p><h4 id="基境"><a href="#基境" class="headerlink" title="基境"></a>基境</h4><p>在编写试时最费时的部分之一就是<strong>编写代码来将整个场景设置成某个已知的状态</strong></p><p>并在测试结束后将其复原到初始状态</p><p>这个已知的状态称为测试的基境( <code>fixture</code> )。</p><p>PHPUnit 支持共享建立基境的代码</p><p>在运行某个测试方法前，会调用一个叫 <code>setUp()</code> 的模板方法</p><p><code>setUp()</code> 是创建测试所用对象的地方</p><p>当测试方法运行结束后，不管成功或失败都会调用 <code>tearDown()</code> 方法</p><p><code>tearDown()</code> 是清理测试所用对象的地方</p><h5 id="setUp-多-tearDown-少"><a href="#setUp-多-tearDown-少" class="headerlink" title="setUp() 多 tearDown() 少"></a>setUp() 多 tearDown() 少</h5><p>实际上只有在 setUp() 中分配类诸如文件或套接字之类的外部资源才需要实现 tearDown()</p><p>如果 setUp() 中只创建纯 PHP 对象，通常可以略过 tearDown()</p><h5 id="如果两个基境建立工作略有不同"><a href="#如果两个基境建立工作略有不同" class="headerlink" title="如果两个基境建立工作略有不同"></a>如果两个基境建立工作略有不同</h5><ul><li>如果两个 <code>setUp()</code> 代码仅有微小差异，把差异代码从 <code>setUp()</code> 移到测试方法内</li><li>如果两个 <code>setUp()</code> 是确实不一样，那么需要另外一个测试用例类</li></ul><h5 id="基境共享"><a href="#基境共享" class="headerlink" title="基境共享"></a>基境共享</h5><p>一个有实际意义的多测试间共享基境的例子是数据库连接</p><p>只登陆数据库一次，然后重用此连接，而不是每个测试都建立一个新的数据库连接</p><p>在同一个测试套件内的不同测试之间共享基境</p><p>用 <code>setUpBeforeClass()</code> 和 <code>tearDownAfterClass()</code> 模板方法来</p><p>分别在测试用例类的第一个测试之前和最后一个测试之后连接与断开数据库</p><h4 id="组织测试"><a href="#组织测试" class="headerlink" title="组织测试"></a>组织测试</h4><p>我们希望能将任意数量的测试以任何组合方式运行</p><ol><li>用文件系统来编排测试套件</li></ol><p>最简单的大概就是把偶有测试用例源文件放在一个测试目录中</p><p>通过对测试目录进行递归遍历，PHPUnit 能自动发现并运行测试</p><p>这种方法的缺点是无法控制测试的运行顺序</p><p>这可能导致测试依赖关系方面的问题</p><ol start="2"><li>用 XML 配置文件也可以用于编排测试套件</li></ol><p>如果phpunit.xml 或 phpunit.xml.dist 存在与当前工作目录且未使用 –configuration</p><p>将自动从此文件中读取配置，可以明确指定测试的执行顺序</p><h4 id="数据库测试"><a href="#数据库测试" class="headerlink" title="数据库测试"></a>数据库测试</h4><p>许多入门与中级的单元测试范例读暗示着这样一种信息</p><p>很容易用简单的测试来对应用程序的逻辑进行测试</p><p>但对于以数据库为中心的应用程序而言，这与现实想去甚远</p><h5 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h5><p>为什么所有单元测试的范例都不包含数据交互？</p><p>这类测试的建立和维护都很复杂。</p><p>对数据库进行测试时，需要考虑以下这些变数 :</p><ol><li>数据库和表</li><li>向表中插入测试所需要的行</li><li>测试运行完毕后验证数据库的状态</li><li>每个新测试都要清理数据库</li></ol><p>另外必须认识到，对于代码而言，本质上来说<strong>数据库是全局输入变量</strong></p><p>一个测试中出现的失败很容易影响到后继的测试结果，从而让整个测试过程变得非常艰难</p><p>随着数据库交互规模的增大，运行测试可能需要耗费可观的时间</p><p>只要保持每个测试所使用的数据量较小并且尽可能用非数据库测试来对代码进行测试</p><h5 id="数据库测试的四个阶段"><a href="#数据库测试的四个阶段" class="headerlink" title="数据库测试的四个阶段"></a>数据库测试的四个阶段</h5><ol><li>建立基境</li><li>执行被测系统</li><li>验证结果</li><li>拆除基境</li></ol><h4 id="测试替身"><a href="#测试替身" class="headerlink" title="测试替身"></a>测试替身</h4><p>有时候对被测系统进行测试是很困难的，因为它依赖于其他无法在测试环境中使用的组件</p><p>这有可能是因为这些组件不可用，它们不会返回测试所需要的结果，或者执行它们会有不良副作用</p><p>在其他情况下，我们的测试策略要求对被测系统的内部行为有更多控制或更多可见性</p><p>如果在编写测试时无法使用（或选择不使用）实际的依赖组件（DOC），可以用测试替身来代替</p><p>测试替身不需要和真正依赖最贱有完全一样的行为方式</p><p>他只需要提供和真正的组件同样的 API 即可，这样被测系统会以为它是真正的组件</p><h4 id="测试实践"><a href="#测试实践" class="headerlink" title="测试实践"></a>测试实践</h4><p>你总能编写更多测试。但是很快就会发现，在所有想得出来的测试中只有很小一部分是真正有用的</p><ul><li><p>需要编写的是那些觉得能运作但却失败或觉得必将失败却成功的测试</p></li><li><p>另一种思考的方式是从成本/收益的关系上去考量，需要编写的是能够给出反馈信息的测试</p></li></ul><h5 id="在开发过程中"><a href="#在开发过程中" class="headerlink" title="在开发过程中"></a>在开发过程中</h5><p>当需要对软件的内部结构进行更改时，你实际上是要在不影响其可见行为的情况下让它更加容易理解、更加易于修改</p><p>测试套件对于安全地进行这些所谓的重构而言是非常宝贵的，否则，你可能在重构的过程中将系统搞坏而不自知</p><p>在使用单元测试来确认重构的转换步骤中确实保持原有行为并且没有引入错误时，以下情况有助于改进项目的编码与设计</p><ol><li>所有单元测试均正确运行</li><li>代码传达其设计原则</li><li>代码没有冗(rong)余</li><li>代码所包含的类和方法的数量降至最低</li></ol><h5 id="在调试过程中"><a href="#在调试过程中" class="headerlink" title="在调试过程中"></a>在调试过程中</h5><p>当看到缺陷报告时，你可能会有尽快修复错误的冲动</p><p>经验表明，这种冲动不是好事，<strong>因为修复一个缺陷很有可能导致另外一个缺陷</strong></p><p>下列操作可以帮你压住冲动</p><ol><li><strong>确认能够重现此缺陷</strong></li><li>在代码中寻找此缺陷最小规模的表达。例如，如果在输出中有一个数字看起来不对，那么就寻找出算出此数字的那个对象</li><li>编写一个目前会失败而缺陷修复将会成功的自动测试</li><li>修复缺陷</li></ol><p>寻找缺陷的最小可靠重现使你有机会切真正检查缺陷的原因</p><p>当修复了缺陷之后，所编写的测试有助于提高缺陷真正被修复的几率</p><p>因为新加入的测试降低了未来修改代码时又破坏此修复的可能性</p><p>而之前所编写的所有测试则降低了在不经意间导致其他问题的可能性</p><div class="post-announce">感谢您的阅读，本文由 <a href="https://double-c.github.io">Double-c</a> 版权所有。如若转载，请注明出处：Double-c（<a href="https://double-c.github.io/2018/05/22/php-unit/">https://double-c.github.io/2018/05/22/php-unit/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/03/25/php-function/" title="php常用函数"><i class="iconfont icon-prev"></i>php常用函数</a></div><div class="post__prev post__prev--right"><a href="/2018/06/14/ali-ems/" title="从零配置阿里云EMS实例">从零配置阿里云EMS实例<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">总不能还没有努力就向生活妥协。</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/那些年踩过的坑/">那些年踩过的坑</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/运维笔记/">运维笔记</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/更好的自己/">更好的自己</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/后端开发/">后端开发</a><span class="block-list-count">11</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2019/05/13/hard-to-run/" title="太用力的人跑不远"><div class="item__cover"><img src="/img/posts/fly.jpg" alt="太用力的人跑不远"></div><div class="item__info"><h3 class="item__title">太用力的人跑不远</h3><span class="item__text">2019-05-13</span></div></a></li><li class="latest-post-item"><a href="/2019/04/23/http-proxy/" title="关于代理两三事"><div class="item__cover"><img src="/img/posts/http.jpg" alt="关于代理两三事"></div><div class="item__info"><h3 class="item__title">关于代理两三事</h3><span class="item__text">2019-04-23</span></div></a></li><li class="latest-post-item"><a href="/2019/03/26/php-design/" title="php设计模式范例"><div class="item__cover"><img src="/img/posts/love_999.jpg" alt="php设计模式范例"></div><div class="item__info"><h3 class="item__title">php设计模式范例</h3><span class="item__text">2019-03-26</span></div></a></li><li class="latest-post-item"><a href="/2019/01/28/php-design-six-rule/" title="设计模式的六大原则"><div class="item__cover"><img src="/img/posts/code.jpg" alt="设计模式的六大原则"></div><div class="item__info"><h3 class="item__title">设计模式的六大原则</h3><span class="item__text">2019-01-28</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/api/">api</a></li><li class="tag-item"><a class="tag-link" href="/tags/git/">git</a></li><li class="tag-item"><a class="tag-link" href="/tags/http/">http</a></li><li class="tag-item"><a class="tag-link" href="/tags/laravel/">laravel</a></li><li class="tag-item"><a class="tag-link" href="/tags/linux/">linux</a></li><li class="tag-item"><a class="tag-link" href="/tags/mac/">mac</a></li><li class="tag-item"><a class="tag-link" href="/tags/php/">php</a></li><li class="tag-item"><a class="tag-link" href="/tags/yii2-0/">yii2.0</a></li><li class="tag-item"><a class="tag-link" href="/tags/人艰不拆/">人艰不拆</a></li><li class="tag-item"><a class="tag-link" href="/tags/自律/">自律</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--4"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Shantou, Guangdong Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>chenchao_cn@qq.com</span></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://github.com/Mrminfive/hexo-theme-skapp" title="hexo-theme-skapp" target="_blank">hexo-theme-skapp</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/Double-C" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:chenchao_cn@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["php"],gitalk=new Gitalk({clientID:"0ab6fbc345e392e6cfb9",clientSecret:"a00e86d6d283eb80bfb5138b1a23e756654883b6",repo:"double-c.github.io",owner:"Double-C",admin:["Double-C"],labels:tags,id:new Date(1526955443e3).getTime()>new Date("2018-02-15").getTime()?md5(location.pathname):location.pathname});gitalk.render("comment-container")</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>